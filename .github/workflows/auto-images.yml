name: 自动处理PSD并更新README

on:
  push:
    paths:
      - '*.psd'       # 监听 PSD 变动
      - 'data.json'   # 关键：监听 JSON 数据变动
      - 'config.txt'  # 监听配置变动
  workflow_dispatch:

permissions:
  contents: write

jobs:
  process-and-update:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 2 #以此获取变动文件列表

      - name: 设置 Python 环境
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: 安装依赖
        run: pip install psd-tools Pillow

      - name: 处理数据与生成图片
        env:
          COMMIT_MSG: ${{ github.event.head_commit.message }}
        run: |
          python3 -c "
          import os
          import json
          import re
          import subprocess
          from psd_tools import PSDImage

          DATA_FILE = 'data.json'
          IMAGE_SIZE = 100 # 默认大小，后续会尝试从config读取

          # --- 1. 读取或初始化 JSON ---
          if os.path.exists(DATA_FILE):
              try:
                  with open(DATA_FILE, 'r', encoding='utf-8') as f:
                      data = json.load(f)
              except:
                  data = {}
          else:
              data = {}

          # --- 2. 获取本次提交变动的文件 (用于判断是否应用 Commit Message) ---
          try:
              # 获取本次 commit 变动的文件列表
              cmd = 'git diff --name-only HEAD~1 HEAD'
              changed_files = subprocess.check_output(cmd, shell=True).decode().splitlines()
          except:
              changed_files = []

          # 解析 Commit Message
          commit_msg = os.environ.get('COMMIT_MSG', '')
          new_name = ''
          new_url = ''
          
          if commit_msg:
              lines = commit_msg.strip().split('\n')
              if lines:
                  new_name = lines[0].strip() # 第一行做名称
                  # 寻找 URL
                  url_pattern = re.compile(r'(https?://[^\s]+)')
                  for line in lines:
                      match = url_pattern.search(line)
                      if match:
                          new_url = match.group(1)
                          break

          # --- 3. 扫描目录下的 PSD 并更新 JSON ---
          current_psds = []
          for file in os.listdir('.'):
              if file.lower().endswith('.psd'):
                  current_psds.append(file)
                  
                  # 如果 JSON 中没有这个文件，或者文件是本次提交且不在JSON里
                  if file not in data:
                      entry = {
                          'file': file,
                          'name': os.path.splitext(file)[0], # 默认文件名
                          'url': ''
                      }
                      
                      # 只有当这个文件在本次变动列表中，才尝试使用 Commit 信息填充
                      if file in changed_files and new_name:
                          print(f'[信息] 检测到新文件 {file}，应用提交信息: {new_name}')
                          entry['name'] = new_name
                          if new_url:
                              entry['url'] = new_url
                      
                      data[file] = entry

          # 清理 JSON 中已经不存在的文件
          for key in list(data.keys()):
              if key not in current_psds:
                  del data[key]

          # 保存更新后的 JSON
          with open(DATA_FILE, 'w', encoding='utf-8') as f:
              json.dump(data, f, ensure_ascii=False, indent=2)

          # --- 4. 转换 PSD 为 PNG ---
          for file in current_psds:
              png_name = os.path.splitext(file)[0] + '.png'
              # 只有 PNG 不存在或 PSD 更新了才转换
              if not os.path.exists(png_name) or os.path.getmtime(file) > os.path.getmtime(png_name):
                  print(f'正在转换: {file} -> {png_name} ...')
                  try:
                      psd = PSDImage.open(file)
                      psd.composite().save(png_name)
                  except Exception as e:
                      print(f'转换失败 {file}: {e}')

          # --- 5. 生成 README 画廊 ---
          
          # 读取 Config 配置
          images_per_row = 4
          if os.path.exists('config.txt'):
              with open('config.txt', 'r', encoding='utf-8') as f:
                  content = f.read()
                  r_row = re.search(r'images_per_row=(\d+)', content)
                  r_size = re.search(r'image_size=(\d+)', content)
                  if r_row: images_per_row = int(r_row.group(1))
                  if r_size: IMAGE_SIZE = int(r_size.group(1))

          # 按照文件修改时间倒序排序（新的在前），或者你可以改为按文件名排序
          # 这里我们把 data 转换为列表进行排序
          sorted_items = sorted(data.values(), key=lambda x: x['name']) 
          # 如果想按上传时间倒序，可以使用 os.path.getmtime(x['file'])

          html_parts = []
          html_parts.append(f'<table style=\"border-collapse: separate; border-spacing: 10px; margin: 0 auto;\">')
          
          item_list = list(sorted_items)
          for i in range(0, len(item_list), images_per_row):
              row_items = item_list[i:i + images_per_row]
              html_parts.append('  <tr>')
              
              for item in row_items:
                  f_name = item['file']
                  d_name = item.get('name', f_name)
                  d_url = item.get('url', '')
                  img_path = os.path.splitext(f_name)[0] + '.png'
                  
                  # 确定点击链接：如果有 URL 则用 URL，否则用图片大图
                  link_href = d_url if d_url else img_path

                  html_parts.append(f'    <td style=\"text-align: center; vertical-align: middle; padding: 10px;\">')
                  html_parts.append(f'      <a href=\"{link_href}\" target=\"_blank\">')
                  html_parts.append(f'        <img src=\"{img_path}\" width=\"{IMAGE_SIZE}\" alt=\"{d_name}\" style=\"border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: block; margin: 0 auto;\">')
                  html_parts.append(f'      </a>')
                  html_parts.append(f'      <p style=\"font-size: 12px; color: #666; margin-top: 5px; text-align: center;\">{d_name}</p>')
                  html_parts.append(f'    </td>')

              # 补齐空格子
              if len(row_items) < images_per_row:
                  for _ in range(images_per_row - len(row_items)):
                      html_parts.append('    <td></td>')
              
              html_parts.append('  </tr>')
          html_parts.append('</table>')

          new_gallery_html = '\n'.join(html_parts)

          # 更新 README
          readme_path = 'README.md'
          if os.path.exists(readme_path):
              with open(readme_path, 'r', encoding='utf-8') as f:
                  content = f.read()
          else:
              content = ''

          start_marker = '<!-- IMAGES_START -->'
          end_marker = '<!-- IMAGES_END -->'

          if start_marker in content and end_marker in content:
              s_idx = content.find(start_marker) + len(start_marker)
              e_idx = content.find(end_marker)
              final_content = content[:s_idx] + '\n' + new_gallery_html + '\n' + content[e_idx:]
          else:
              final_content = content + '\n\n' + start_marker + '\n' + new_gallery_html + '\n' + end_marker + '\n'

          with open(readme_path, 'w', encoding='utf-8') as f:
              f.write(final_content)
          "

      - name: 提交更改
        run: |
          git config --global user.name 'GitHub Action'
          git config --global user.email 'action@github.com'
          
          git add *.png
          git add README.md
          git add data.json
          
          git diff --quiet && git diff --staged --quiet || (git commit -m "Auto update: JSON, PNG and README" && git push)
